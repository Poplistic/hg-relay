<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{
	margin:0;
	width:100%;
	height:100%;
	overflow:hidden;
	background:radial-gradient(circle at 50% 15%, #160406, #020001);
	font-family:system-ui,Segoe UI,sans-serif;
}
#hud{
	position:fixed;
	top:16px;
	left:16px;
	z-index:10;
	color:#ffe8ee;
}
.name{
	margin-top:6px;
	padding:6px 8px;
	border-radius:10px;
	cursor:pointer;
	background:rgba(255,80,100,.08);
}
.name:hover{
	background:rgba(255,120,140,.28);
}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>
<body>
<div id="hud"></div>

<script type="module">
import * as THREE from "three";

/* ====================== RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.autoClear = false;
document.body.appendChild(renderer.domElement);

/* ====================== SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050001);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(0,1200,1800);

/* ====================== LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff,.35));
const sun = new THREE.DirectionalLight(0xffc0cc,1.3);
sun.position.set(3000,6000,2000);
scene.add(sun);

/* ====================== PLAYERS ================= */
const hud = document.getElementById("hud");
const players = new Map();

function makePlayer(userId){
	const group = new THREE.Group();

	const tex = new THREE.TextureLoader().load(`/bust/${userId}`);
	const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true });
	const plane = new THREE.Mesh(new THREE.PlaneGeometry(30,30), mat);
	plane.rotation.x = -Math.PI/2;
	group.add(plane);

	scene.add(group);
	return group;
}

async function updatePlayers(){
	const data = await fetch("/map").then(r=>r.json());
	hud.innerHTML = "<b>Players:</b><br>";
	const alive = new Set();

	for(const p of data){
		alive.add(p.id);
		if(!players.has(p.id)) players.set(p.id, makePlayer(p.id));
		const m = players.get(p.id);
		m.position.set(p.x, p.y+20, p.z);
		hud.innerHTML += `<div class="name">${p.name}</div>`;
	}

	for(const id of players.keys()){
		if(!alive.has(id)){
			scene.remove(players.get(id));
			players.delete(id);
		}
	}
}

setInterval(updatePlayers,200);

/* ====================== POST-PROCESSING SHADER ================= */
const rt = new THREE.WebGLRenderTarget(innerWidth, innerHeight);
rt.depthTexture = new THREE.DepthTexture();

const postScene = new THREE.Scene();
const postCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

const postMat = new THREE.ShaderMaterial({
	uniforms:{
		tColor:{value:rt.texture},
		tDepth:{value:rt.depthTexture},
		res:{value:new THREE.Vector2(innerWidth,innerHeight)},
		near:{value:camera.near},
		far:{value:camera.far}
	},
	vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position.xy,0,1);}`,
	fragmentShader:`
precision highp float;
varying vec2 vUv;
uniform sampler2D tColor,tDepth;
uniform vec2 res;
uniform float near,far;
float lin(float d){
	float z=d*2.-1.;
	return (2.*near*far)/(far+near-z*(far-near));
}
void main(){
	vec3 col=texture2D(tColor,vUv).rgb;
	float d=lin(texture2D(tDepth,vUv).r)/far;
	vec2 px=1./res;
	float e=abs(d-lin(texture2D(tDepth,vUv+vec2(px.x,0)).r)/far)
	       +abs(d-lin(texture2D(tDepth,vUv+vec2(0,px.y)).r)/far);
	col+=e*vec3(1.,.3,.4);
	col=mix(col,vec3(.18,.02,.04),smoothstep(.25,.9,d));
	gl_FragColor=vec4(col,1.);
}`
});
postScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), postMat));

/* ====================== CAMERA ================= */
const cam = { yaw:0, pitch:0, velocity:new THREE.Vector3(), accel:2.4, damping:0.88, baseSpeed:18, boost:3 };
const keys = { w:false,a:false,s:false,d:false,shift:false };
let rotating=false;

/* Mouse */
renderer.domElement.addEventListener("mousedown",e=>{
	if(e.button===0){ rotating=true; renderer.domElement.requestPointerLock(); }
});
addEventListener("mouseup",()=>{ rotating=false; document.exitPointerLock(); });
addEventListener("mousemove",e=>{
	if(rotating && document.pointerLockElement){
		cam.yaw   -= e.movementX*0.002;
		cam.pitch = Math.max(-1.4,Math.min(1.4, cam.pitch - e.movementY*0.002));
	}
});

/* Keyboard */
addEventListener("keydown",e=>{
	if(e.code==="KeyW") keys.w=true;
	if(e.code==="KeyA") keys.a=true;
	if(e.code==="KeyS") keys.s=true;
	if(e.code==="KeyD") keys.d=true;
	if(e.code==="ShiftLeft") keys.shift=true;
});
addEventListener("keyup",e=>{
	if(e.code==="KeyW") keys.w=false;
	if(e.code==="KeyA") keys.a=false;
	if(e.code==="KeyS") keys.s=false;
	if(e.code==="KeyD") keys.d=false;
	if(e.code==="ShiftLeft") keys.shift=false;
});

/* ====================== LOOP ================= */
function animate(){
	requestAnimationFrame(animate);

	camera.rotation.order="YXZ";
	camera.rotation.y=cam.yaw;
	camera.rotation.x=cam.pitch;

	const forward = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
	const right   = new THREE.Vector3(1,0,0).applyEuler(camera.rotation);
	let mult = cam.baseSpeed;
	if(keys.shift) mult*=cam.boost;

	if(keys.w) cam.velocity.addScaledVector(forward, cam.accel*mult);
	if(keys.s) cam.velocity.addScaledVector(forward,-cam.accel*mult);
	if(keys.a) cam.velocity.addScaledVector(right, -cam.accel*mult);
	if(keys.d) cam.velocity.addScaledVector(right, cam.accel*mult);

	cam.velocity.multiplyScalar(cam.damping);
	camera.position.add(cam.velocity);

	renderer.setRenderTarget(rt);
	renderer.render(scene,camera);
	renderer.setRenderTarget(null);
	renderer.render(postScene,postCam);
}
animate();

/* ====================== RESIZE ================= */
addEventListener("resize",()=>{
	camera.aspect=innerWidth/innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth,innerHeight);
	rt.setSize(innerWidth,innerHeight);
	postMat.uniforms.res.value.set(innerWidth,innerHeight);
});
</script>
</body>
</html>
