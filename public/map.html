<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #050001;
    font-family: system-ui, Segoe UI, sans-serif;
    color: #ffe8ee;
}
#ui {
    position: fixed;
    top: 16px;
    left: 16px;
    background: rgba(20,5,10,0.35);
    border-radius: 14px;
    padding: 12px;
    z-index: 10;
}
.name {
    margin-top: 6px;
    padding: 6px 8px;
    border-radius: 10px;
    cursor: pointer;
    background: rgba(255,80,100,0.08);
}
.name:hover {
    background: rgba(255,120,140,0.28);
}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>
<body>

<div id="ui"></div>

<script type="module">
import * as THREE from "three";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= CAMERAS ================= */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(0, 1200, 1800);

/* ================= SCENES ================= */
const scene = new THREE.Scene();           // world (affected)
const overlayScene = new THREE.Scene();    // sprites (clean)

/* ================= LIGHTING ================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sun = new THREE.DirectionalLight(0xffc0cc, 1.3);
sun.position.set(3000, 6000, 2000);
scene.add(sun);

/* ================= ARENA ================= */
new OBJLoader().load("/arena.obj", obj => {
    obj.traverse(n=>{
        if(n.isMesh){
            n.material = new THREE.MeshStandardMaterial({
                color: 0x5a141d,
                roughness: 0.65,
                emissive: 0x2a060b,
                emissiveIntensity: 0.35
            });
        }
    });
    scene.add(obj);
});

/* ================= POST PROCESS ================= */
const rt = new THREE.WebGLRenderTarget(innerWidth, innerHeight);
rt.depthTexture = new THREE.DepthTexture();

const postScene = new THREE.Scene();
const postCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

const postMat = new THREE.ShaderMaterial({
uniforms:{
    tColor:{value:rt.texture},
    tDepth:{value:rt.depthTexture},
    res:{value:new THREE.Vector2(innerWidth, innerHeight)},
    near:{value:camera.near},
    far:{value:camera.far}
},
vertexShader:`
varying vec2 vUv;
void main(){
    vUv=uv;
    gl_Position=vec4(position.xy,0.,1.);
}`,
fragmentShader:`
precision highp float;
varying vec2 vUv;
uniform sampler2D tColor;
uniform sampler2D tDepth;
uniform float near;
uniform float far;

float linearize(float d){
    float z=d*2.-1.;
    return (2.*near*far)/(far+near-z*(far-near));
}

void main(){
    vec3 col=texture2D(tColor,vUv).rgb;
    float d=linearize(texture2D(tDepth,vUv).r)/far;

    float edge =
        abs(d - linearize(texture2D(tDepth,vUv+vec2(1./1024.,0.)).r)/far) +
        abs(d - linearize(texture2D(tDepth,vUv+vec2(0.,1./1024.)).r)/far);

    col += edge * vec3(1.,0.3,0.4);
    col = mix(col, vec3(0.18,0.02,0.04), smoothstep(0.3,0.9,d));

    gl_FragColor=vec4(col,1.);
}`
});
postScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), postMat));

/* ================= PLAYERS ================= */
const players = new Map();
const ui = document.getElementById("ui");

function makePlayer(p){
    const g = new THREE.Group();

    const tex = new THREE.TextureLoader().load(`/bust/${p.id}`);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
        map: tex,
        depthTest: false
    }));
    sprite.scale.set(60,60,1);
    g.add(sprite);

    overlayScene.add(g);
    return g;
}

async function updatePlayers(){
    const data = await fetch("/map").then(r=>r.json());
    ui.innerHTML="<b>Tributes</b>";
    const alive=new Set();

    for(const p of data){
        alive.add(p.id);
        if(!players.has(p.id)){
            players.set(p.id, makePlayer(p));
        }
        const m=players.get(p.id);
        m.position.set(p.x,p.y+80,p.z);

        const d=document.createElement("div");
        d.className="name";
        d.textContent=p.name;
        ui.appendChild(d);
    }

    for(const [id,m] of players){
        if(!alive.has(id)){
            overlayScene.remove(m);
            players.delete(id);
        }
    }
}
setInterval(updatePlayers,200);

/* ================= CAMERA ================= */
const cam={yaw:0,pitch:0,vel:new THREE.Vector3()};
addEventListener("mousemove",e=>{
    if(document.pointerLockElement){
        cam.yaw-=e.movementX*0.002;
        cam.pitch=Math.max(-1.4,Math.min(1.4,cam.pitch-e.movementY*0.002));
    }
});
renderer.domElement.onclick=()=>renderer.domElement.requestPointerLock();

/* ================= LOOP ================= */
function animate(){
    requestAnimationFrame(animate);

    camera.rotation.order="YXZ";
    camera.rotation.y=cam.yaw;
    camera.rotation.x=cam.pitch;

    for(const [,p] of players){
        p.quaternion.copy(camera.quaternion);
    }

    renderer.setRenderTarget(rt);
    renderer.render(scene,camera);
    renderer.setRenderTarget(null);
    renderer.render(postScene,postCam);
    renderer.render(overlayScene,camera);
}
animate();

addEventListener("resize",()=>{
    renderer.setSize(innerWidth,innerHeight);
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
});
</script>
</body>
</html>
