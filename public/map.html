<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html,body{
	margin:0;
	width:100%;
	height:100%;
	overflow:hidden;
	background:radial-gradient(circle at 50% 15%,#2b0f14,#090205);
	font-family:system-ui,Segoe UI,sans-serif;
}
#hud{
	position:fixed;
	top:16px;
	left:16px;
	z-index:10;
}
.ui{
	min-width:180px;
	color:#ffe8ee;
	background:linear-gradient(180deg,rgba(255,130,150,.25),rgba(90,20,30,.18));
	backdrop-filter:blur(14px);
	border:1px solid rgba(255,160,170,.45);
	border-radius:16px;
	padding:12px;
	box-shadow:0 14px 40px rgba(255,70,90,.3);
}
.ui b{
	font-size:11px;
	letter-spacing:.12em;
	text-transform:uppercase;
}
.name{
	margin-top:4px;
	padding:6px 8px;
	border-radius:10px;
	cursor:pointer;
	background:rgba(255,120,140,.08);
}
.name:hover{
	background:rgba(255,140,160,.28);
}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>
<div id="hud"><div class="ui" id="ui"></div></div>

<script type="module">
import * as THREE from "three";

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.autoClear=false;
document.body.appendChild(renderer.domElement);

/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x120608);

const camera = new THREE.PerspectiveCamera(60,innerWidth/innerHeight,1,20000);
camera.position.set(0,1200,1800);

scene.add(new THREE.AmbientLight(0xffffff,.55));
const sun=new THREE.DirectionalLight(0xffe2e6,1.4);
sun.position.set(3000,6000,2000);
scene.add(sun);

/* ================= FRUSTUM ================= */
const frustum=new THREE.CameraHelper(camera);
frustum.material.transparent=true;
frustum.material.opacity=.35;
scene.add(frustum);

/* ================= UI ================= */
const ui=document.getElementById("ui");

/* ================= PLAYERS ================= */
const players=new Map();
const trails=new THREE.Group();
scene.add(trails);

function makePlayer(){
	const g=new THREE.Group();

	const body=new THREE.Mesh(
		new THREE.SphereGeometry(10,24,24),
		new THREE.MeshStandardMaterial({
			color:0xff6b7a,
			emissive:0xff2a40,
			emissiveIntensity:.6
		})
	);

	const vision=new THREE.Mesh(
		new THREE.ConeGeometry(160,420,48,1,true),
		new THREE.MeshBasicMaterial({
			color:0xff5566,
			transparent:true,
			opacity:.08,
			side:THREE.DoubleSide,
			depthWrite:false
		})
	);
	vision.rotation.x=Math.PI/2;
	vision.position.z=-210;

	g.add(body);
	g.add(vision);
	g.userData.vision=vision;
	return g;
}

function addTrail(pos){
	const m=new THREE.Mesh(
		new THREE.PlaneGeometry(36,36),
		new THREE.MeshBasicMaterial({
			color:0xff4058,
			transparent:true,
			opacity:.12,
			depthWrite:false
		})
	);
	m.rotation.x=-Math.PI/2;
	m.position.copy(pos);
	trails.add(m);
	setTimeout(()=>trails.remove(m),3000);
}

/* ================= UPDATE ================= */
async function updatePlayers(){
	const data=await fetch("/map").then(r=>r.json());
	ui.innerHTML="<b>Tributes</b>";

	const alive=new Set();
	for(const p of data){
		alive.add(p.id);
		if(!players.has(p.id)){
			const m=makePlayer();
			scene.add(m);
			players.set(p.id,m);
		}
		const m=players.get(p.id);
		addTrail(m.position.clone());

		m.position.set(p.x,p.y,p.z);
		m.rotation.y=p.yaw;
		m.userData.vision.rotation.z=p.pitch;

		const d=document.createElement("div");
		d.className="name";
		d.textContent=p.name;
		d.onclick=()=>follow=m;
		ui.appendChild(d);
	}
	for(const [id,m] of players){
		if(!alive.has(id)){
			scene.remove(m);
			players.delete(id);
		}
	}
}
setInterval(updatePlayers,200);

/* ================= CAMERA CONTROL ================= */
let follow=null;
const cam={yaw:0,pitch:0};

renderer.domElement.addEventListener("mousedown",()=>renderer.domElement.requestPointerLock());
addEventListener("mousemove",e=>{
	if(document.pointerLockElement){
		cam.yaw-=e.movementX*.002;
		cam.pitch=Math.max(-1.4,Math.min(1.4,cam.pitch-e.movementY*.002));
	}
});

/* ================= POST FX ================= */
const rt=new THREE.WebGLRenderTarget(innerWidth,innerHeight);
rt.depthTexture=new THREE.DepthTexture();

const postScene=new THREE.Scene();
const postCam=new THREE.OrthographicCamera(-1,1,1,-1,0,1);

const postMat=new THREE.ShaderMaterial({
	uniforms:{
		tColor:{value:rt.texture},
		tDepth:{value:rt.depthTexture},
		res:{value:new THREE.Vector2(innerWidth,innerHeight)},
		near:{value:camera.near},
		far:{value:camera.far}
	},
	vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position.xy,0,1);}`,
	fragmentShader:`
precision highp float;
varying vec2 vUv;
uniform sampler2D tColor,tDepth;
uniform vec2 res;
uniform float near,far;

float lin(float d){
	float z=d*2.-1.;
	return (2.*near*far)/(far+near-z*(far-near));
}
void main(){
	vec3 col=texture2D(tColor,vUv).rgb;
	float d=lin(texture2D(tDepth,vUv).r)/far;
	vec2 px=1./res;
	float e=abs(d-lin(texture2D(tDepth,vUv+vec2(px.x,0)).r)/far)
	       +abs(d-lin(texture2D(tDepth,vUv+vec2(0,px.y)).r)/far);
	col+=e*vec3(1.,.4,.5);
	col=mix(col,vec3(.35,.12,.16),smoothstep(.3,.95,d));
	gl_FragColor=vec4(col,1.);
}`
});
postScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2),postMat));

/* ================= LOOP ================= */
function animate(){
	requestAnimationFrame(animate);

	camera.rotation.order="YXZ";
	camera.rotation.y=cam.yaw;
	camera.rotation.x=cam.pitch;

	if(follow){
		const t=follow.position.clone();
		const off=new THREE.Vector3(0,140,-320).applyEuler(camera.rotation);
		camera.position.lerp(t.add(off),.08);
	}

	frustum.update();

	renderer.setRenderTarget(rt);
	renderer.render(scene,camera);
	renderer.setRenderTarget(null);
	renderer.render(postScene,postCam);
}
animate();

addEventListener("resize",()=>{
	renderer.setSize(innerWidth,innerHeight);
	rt.setSize(innerWidth,innerHeight);
	camera.aspect=innerWidth/innerHeight;
	camera.updateProjectionMatrix();
	postMat.uniforms.res.value.set(innerWidth,innerHeight);
});
</script>
</body>
</html>
