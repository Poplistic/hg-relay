<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { CSS2DRenderer, CSS2DObject } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js";
import { Sky } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/objects/Sky.js";

/* ======================
   CONFIG
====================== */

const DOT_RADIUS = 5;
const HITBOX_RADIUS = 40;
const PREDICTION_TIME = 0.15;
const GROUND_RAY_HEIGHT = 500;
const GROUND_OFFSET = 8;

/* ======================
   RENDERERS
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position = "absolute";
labelRenderer.domElement.style.top = "0";
labelRenderer.domElement.style.pointerEvents = "none";
document.body.appendChild(labelRenderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 20000);
camera.position.set(2000, 1600, 2000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   SKY / LIGHTS
====================== */

const sky = new Sky();
sky.scale.setScalar(10000);
scene.add(sky);

const sun = new THREE.Vector3();
sky.material.uniforms.turbidity.value = 10;
sky.material.uniforms.rayleigh.value = 2;

const dirLight = new THREE.DirectionalLight(0xffffff, 3);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404060, 0.4));

/* ======================
   KILL FEED UI
====================== */

const killFeed = document.createElement("div");
killFeed.style.position = "absolute";
killFeed.style.left = "10px";
killFeed.style.bottom = "10px";
killFeed.style.fontFamily = "sans-serif";
killFeed.style.color = "white";
killFeed.style.pointerEvents = "none";
document.body.appendChild(killFeed);

function addKillFeed(text) {
	const row = document.createElement("div");
	row.textContent = text;
	row.style.background = "rgba(0,0,0,0.6)";
	row.style.padding = "6px 10px";
	row.style.marginTop = "6px";
	row.style.borderRadius = "6px";
	row.style.animation = "fadeout 6s forwards";

	killFeed.appendChild(row);
	setTimeout(() => row.remove(), 6000);
}

const style = document.createElement("style");
style.textContent = `
@keyframes fadeout {
	0% { opacity: 1 }
	70% { opacity: 1 }
	100% { opacity: 0 }
}`;
document.head.appendChild(style);

/* ======================
   PLAYER MARKERS
====================== */

const playerGroup = new THREE.Group();
scene.add(playerGroup);

function makeMarker(name) {
	const g = new THREE.Group();

	const dot = new THREE.Mesh(
		new THREE.SphereGeometry(DOT_RADIUS, 16, 16),
		new THREE.MeshBasicMaterial({ color: 0x00ff00 })
	);
	g.add(dot);

	const hitbox = new THREE.Mesh(
		new THREE.SphereGeometry(HITBOX_RADIUS),
		new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
	);
	g.add(hitbox);

	const div = document.createElement("div");
	div.style.color = "#0ff";
	div.style.fontWeight = "bold";
	div.style.textShadow = "0 0 4px black";
	const label = new CSS2DObject(div);
	label.position.set(0, 25, 0);
	label.visible = false;
	g.add(label);

	g.userData = {
		name,
		dot,
		hitbox,
		label,
		lastPos: null,
		lastTime: 0,
		velocity: new THREE.Vector3()
	};

	return g;
}

const markers = new Map();
let tracked = null;

/* ======================
   GROUND RAYCAST
====================== */

const groundRay = new THREE.Raycaster();
const down = new THREE.Vector3(0, -1, 0);

function snapToGround(pos) {
	groundRay.set(
		new THREE.Vector3(pos.x, GROUND_RAY_HEIGHT, pos.z),
		down
	);

	const grounds = [];
	scene.traverse(o => {
		if (o.isMesh && o.userData.isGround) grounds.push(o);
	});

	if (!grounds.length) return pos;

	const hits = groundRay.intersectObjects(grounds, true);
	if (hits.length) {
		pos.y = hits[0].point.y + GROUND_OFFSET;
	}
	return pos;
}

/* ======================
   UPDATE PLAYERS
====================== */

function updatePlayers(data) {
	const seen = new Set();

	for (const p of data) {
		seen.add(p.id);

		if (!markers.has(p.id)) {
			const m = makeMarker(p.name);
			playerGroup.add(m);
			markers.set(p.id, m);
		}

		const m = markers.get(p.id);
		const now = performance.now() / 1000;
		const pos = new THREE.Vector3(p.x, 0, p.z);

		if (m.userData.lastPos) {
			const dt = Math.max(now - m.userData.lastTime, 0.016);
			m.userData.velocity.copy(pos).sub(m.userData.lastPos).divideScalar(dt);
		}

		m.userData.lastPos = pos.clone();
		m.userData.lastTime = now;

		const predicted = pos.clone().add(
			m.userData.velocity.clone().multiplyScalar(PREDICTION_TIME)
		);

		m.position.lerp(snapToGround(predicted), 0.5);
	}

	// Detect deaths
	for (const [id, m] of markers) {
		if (!seen.has(id)) {
			addKillFeed(`${m.userData.name} eliminated`);
			playerGroup.remove(m);
			markers.delete(id);
			if (tracked === m) tracked = null;
		}
	}
}

/* ======================
   FETCH LOOP
====================== */

setInterval(async () => {
	updatePlayers(await fetch("/map").then(r => r.json()));
}, 200);

/* ======================
   PICKING
====================== */

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

renderer.domElement.addEventListener("click", e => {
	const rect = renderer.domElement.getBoundingClientRect();
	pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
	pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

	raycaster.setFromCamera(pointer, camera);
	const hitboxes = [...markers.values()].map(m => m.userData.hitbox);
	const hits = raycaster.intersectObjects(hitboxes);
	tracked = hits.length ? hits[0].object.parent : null;
});

/* ======================
   ANIMATE
====================== */

function animate() {
	requestAnimationFrame(animate);

	markers.forEach(m => {
		const sel = m === tracked;
		m.userData.dot.material.color.set(sel ? 0x00ffff : 0x00ff00);
		m.userData.label.visible = sel;

		if (sel) {
			const dist = camera.position.distanceTo(m.position);
			m.userData.label.element.textContent =
				`${m.userData.name} (${Math.floor(dist)} studs)`;
		}
	});

	if (tracked) {
		camera.position.lerp(
			tracked.position.clone().add(new THREE.Vector3(0, 900, 900)),
			0.05
		);
		controls.target.lerp(tracked.position, 0.1);
	}

	controls.update();
	renderer.render(scene, camera);
	labelRenderer.render(scene, camera);
}

animate();
</script>
