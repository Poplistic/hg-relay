<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
    margin: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: radial-gradient(circle at center, #120308, #050001);
    font-family: system-ui, Segoe UI, sans-serif;
    color: #ffe8ee;
}

#ui {
    position: fixed;
    top: 16px;
    left: 16px;
    background: linear-gradient(180deg, rgba(40,10,18,0.75), rgba(10,2,6,0.6));
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    z-index: 10;
}

.name {
    margin-top: 6px;
    padding: 6px 10px;
    border-radius: 12px;
    background: linear-gradient(90deg, rgba(255,80,100,0.25), rgba(255,80,100,0.05));
    box-shadow: inset 0 0 12px rgba(255,80,100,0.25);
    font-size: 14px;
}

canvas { display:block }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>
<body>

<div id="ui"><b>Tributes</b></div>

<script type="module">
import * as THREE from "three";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ================= RENDERER ================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.15;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ================= SCENE ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x050001, 1200, 6500);

/* ================= SKY GRADIENT ================= */
const skyGeo = new THREE.SphereGeometry(10000, 32, 32);
const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
        top:    { value: new THREE.Color(0x2b0b15) },
        bottom: { value: new THREE.Color(0x050001) }
    },
    vertexShader: `
        varying vec3 vPos;
        void main(){
            vPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `,
    fragmentShader: `
        varying vec3 vPos;
        uniform vec3 top;
        uniform vec3 bottom;
        void main(){
            float h = normalize(vPos).y * 0.5 + 0.5;
            gl_FragColor = vec4(mix(bottom, top, h), 1.0);
        }
    `
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

/* ================= CAMERA ================= */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(0, 900, 1700);

/* ================= LIGHTING ================= */
scene.add(new THREE.AmbientLight(0xffb6c1, 0.35));

const sun = new THREE.DirectionalLight(0xffc0cc, 1.6);
sun.position.set(5000, 7000, 4000);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
scene.add(sun);

const rim = new THREE.DirectionalLight(0xff5070, 0.6);
rim.position.set(-3000, 2000, -4000);
scene.add(rim);

/* ================= FLOOR ================= */
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(7000, 7000, 64, 64),
    new THREE.MeshStandardMaterial({
        color: 0x2a070b,
        roughness: 0.9,
        metalness: 0.05
    })
);
floor.rotation.x = -Math.PI / 2;
floor.receiveShadow = true;
scene.add(floor);

/* ================= GRID OVERLAY ================= */
const grid = new THREE.GridHelper(7000, 80, 0x66111f, 0x22060a);
grid.material.transparent = true;
grid.material.opacity = 0.25;
scene.add(grid);

/* ================= ARENA OBJ ================= */
const loader = new OBJLoader();

loader.load("/arena.obj", obj => {
    obj.traverse(n => {
        if (n.isMesh) {
            n.material = new THREE.MeshStandardMaterial({
                color: 0x7a1b28,
                roughness: 0.55,
                metalness: 0.08,
                emissive: 0x2a060c,
                emissiveIntensity: 0.45
            });
            n.receiveShadow = true;
        }
    });

    obj.scale.setScalar(10);
    obj.rotation.y = Math.PI;
    scene.add(obj);
});

/* ================= PLAYERS ================= */
const players = new Map();
const ui = document.getElementById("ui");
const texLoader = new THREE.TextureLoader();

function makePlayer(p){
    const mat = new THREE.SpriteMaterial({
        map: texLoader.load(`/bust/${p.id}`),
        transparent: true,
        depthTest: false
    });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(90, 90, 1);
    scene.add(sprite);
    return sprite;
}

async function updatePlayers(){
    let data;
    try {
        const r = await fetch("/map");
        if(!r.ok) return;
        data = await r.json();
    } catch { return; }

    ui.innerHTML = "<b>Tributes</b>";
    const alive = new Set();

    for(const p of data){
        alive.add(p.id);

        if(!players.has(p.id)){
            players.set(p.id, makePlayer(p));
        }

        const m = players.get(p.id);
        m.position.set(p.x, p.y + 90, p.z);

        const d = document.createElement("div");
        d.className = "name";
        d.textContent = p.name;
        ui.appendChild(d);
    }

    for(const [id,m] of players){
        if(!alive.has(id)){
            scene.remove(m);
            players.delete(id);
        }
    }
}
setInterval(updatePlayers, 250);

/* ================= CONTROLS ================= */
const cam = { yaw:0, pitch:0 };
const keys = Object.create(null);

addEventListener("keydown", e => keys[e.code] = true);
addEventListener("keyup",   e => keys[e.code] = false);

addEventListener("mousemove", e=>{
    if(document.pointerLockElement){
        cam.yaw   -= e.movementX * 0.002;
        cam.pitch -= e.movementY * 0.002;
        cam.pitch = Math.max(-1.4, Math.min(1.4, cam.pitch));
    }
});
renderer.domElement.onclick = () =>
    renderer.domElement.requestPointerLock();

/* ================= LOOP ================= */
function animate(){
    requestAnimationFrame(animate);

    const speed = 30;

    const forward = new THREE.Vector3(
        Math.sin(cam.yaw), 0, Math.cos(cam.yaw)
    );
    const right = new THREE.Vector3(
        Math.cos(cam.yaw), 0, -Math.sin(cam.yaw)
    );

    if(keys.KeyW) camera.position.addScaledVector(forward, -speed);
    if(keys.KeyS) camera.position.addScaledVector(forward,  speed);
    if(keys.KeyA) camera.position.addScaledVector(right,   -speed);
    if(keys.KeyD) camera.position.addScaledVector(right,    speed);

    camera.rotation.order = "YXZ";
    camera.rotation.y = cam.yaw;
    camera.rotation.x = cam.pitch;

    for(const [,p] of players){
        p.quaternion.copy(camera.quaternion);
    }

    renderer.render(scene, camera);
}
animate();

/* ================= RESIZE ================= */
addEventListener("resize", ()=>{
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
});
</script>
</body>
</html>
