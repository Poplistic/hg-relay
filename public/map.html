<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HG Arena â€” Cinematic Scanner</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
	html, body {
		margin: 0;
		width: 100%;
		height: 100%;
		overflow: hidden;
		background: #02030a;
		font-family: system-ui, sans-serif;
	}
	canvas { display: block; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { ShaderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050914, 0.00035);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 9000);
camera.position.set(1800, 1400, 1800);

/* ======================
   SKY
====================== */

const sky = new THREE.Mesh(
	new THREE.SphereGeometry(8000, 32, 32),
	new THREE.ShaderMaterial({
		side: THREE.BackSide,
		uniforms: {
			top: { value: new THREE.Color(0x0b1d4a) },
			bottom: { value: new THREE.Color(0x02030a) }
		},
		vertexShader: `
			varying vec3 vPos;
			void main() {
				vPos = position;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			}
		`,
		fragmentShader: `
			uniform vec3 top;
			uniform vec3 bottom;
			varying vec3 vPos;
			void main() {
				float h = normalize(vPos).y * 0.5 + 0.5;
				gl_FragColor = vec4(mix(bottom, top, h), 1.0);
			}
		`
	})
);
scene.add(sky);

/* ======================
   CONTROLS
====================== */

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;

/* ======================
   LIGHTING
====================== */

scene.add(new THREE.AmbientLight(0x223366, 0.5));

const sun = new THREE.DirectionalLight(0x99ccff, 1.6);
sun.position.set(1200, 2000, 900);
scene.add(sun);

/* ======================
   ARENA
====================== */

new OBJLoader().load("./arena.obj", obj => {
	obj.traverse(m => {
		if (!m.isMesh) return;
		m.material = new THREE.MeshStandardMaterial({
			color: 0x0a1022,
			roughness: 0.85,
			metalness: 0.15,
			emissive: 0x03060f
		});
	});
	scene.add(obj);
});

/* ======================
   POSTPROCESS
====================== */

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

composer.addPass(new UnrealBloomPass(
	new THREE.Vector2(innerWidth, innerHeight),
	1.1,
	0.55,
	0.15
));

/* ======================
   COLOR GRADING (LUT-LIKE)
====================== */

const ColorGradePass = new ShaderPass({
	uniforms: { tDiffuse: { value: null } },
	vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position.xy,0.0,1.0);
		}
	`,
	fragmentShader: `
		uniform sampler2D tDiffuse;
		varying vec2 vUv;

		vec3 filmic(vec3 c) {
			c = max(vec3(0.0), c - 0.004);
			return (c * (6.2*c + 0.5)) / (c * (6.2*c + 1.7) + 0.06);
		}

		void main() {
			vec3 col = texture2D(tDiffuse, vUv).rgb;

			col = mix(col, vec3(dot(col, vec3(0.333))), 0.08);
			col.r += 0.02;
			col.b -= 0.02;

			col = filmic(col);
			gl_FragColor = vec4(col,1.0);
		}
	`
});
composer.addPass(ColorGradePass);

/* ======================
   SCANLINES
====================== */

const ScanlinePass = new ShaderPass({
	uniforms: {
		tDiffuse: { value: null },
		time: { value: 0 }
	},
	vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position.xy,0.0,1.0);
		}
	`,
	fragmentShader: `
		uniform sampler2D tDiffuse;
		uniform float time;
		varying vec2 vUv;

		void main() {
			vec3 col = texture2D(tDiffuse, vUv).rgb;
			float scan = sin((vUv.y + time*0.02) * 900.0) * 0.04;
			col -= scan;
			gl_FragColor = vec4(col,1.0);
		}
	`
});
composer.addPass(ScanlinePass);

/* ======================
   FILM GRAIN
====================== */

const GrainPass = new ShaderPass({
	uniforms: {
		tDiffuse: { value: null },
		time: { value: 0 }
	},
	vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position.xy,0.0,1.0);
		}
	`,
	fragmentShader: `
		uniform sampler2D tDiffuse;
		uniform float time;
		varying vec2 vUv;

		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}

		void main() {
			vec3 col = texture2D(tDiffuse, vUv).rgb;
			float g = rand(vUv + time) * 0.035;
			col += g;
			gl_FragColor = vec4(col,1.0);
		}
	`
});
composer.addPass(GrainPass);

/* ======================
   ANIMATE
====================== */

function animate(t) {
	requestAnimationFrame(animate);
	controls.update();

	ScanlinePass.uniforms.time.value = t * 0.001;
	GrainPass.uniforms.time.value = t * 0.001;

	composer.render();
}
animate();

/* ======================
   RESIZE
====================== */

addEventListener("resize", () => {
	camera.aspect = innerWidth / innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);
	composer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
