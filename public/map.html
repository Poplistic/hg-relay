import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/postprocessing/RenderPass.js";
import { ShaderPass } from "https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/postprocessing/ShaderPass.js";

const MAX_PLAYERS = 32;
const ARENA_RADIUS = 3000;

/* =========================
   SCENE
========================= */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.autoClear = false;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 1, 10000);
camera.position.set(2000, 1800, 2000);
camera.lookAt(0, 0, 0);

/* =========================
   ARENA (placeholder mesh)
========================= */

const arena = new THREE.Mesh(
	new THREE.CylinderGeometry(ARENA_RADIUS, ARENA_RADIUS, 200, 128, 1, true),
	new THREE.MeshStandardMaterial({
		color: 0x111111,
		roughness: 1,
		metalness: 0
	})
);
arena.position.y = -100;
scene.add(arena);

const light = new THREE.DirectionalLight(0xffffff, 0.8);
light.position.set(300, 800, 200);
scene.add(light);

/* =========================
   PLAYER STATE
========================= */

const players = new Map(); // id â†’ { pos, fade }

/* =========================
   PLAYER MARKERS
========================= */

const markerGeo = new THREE.SphereGeometry(20, 16, 16);
const markerMat = new THREE.MeshBasicMaterial({ color: 0xff3333 });

function getMarker(id) {
	if (!players.has(id)) {
		const mesh = new THREE.Mesh(markerGeo, markerMat.clone());
		scene.add(mesh);
		players.set(id, { mesh, fade: 1 });
	}
	return players.get(id);
}

/* =========================
   FETCH PLAYERS
========================= */

async function updatePlayers() {
	const data = await fetch("/map").then(r => r.json());

	const alive = new Set();

	for (const p of data) {
		alive.add(p.userId);
		const pl = getMarker(p.userId);
		pl.mesh.position.set(p.x, 10, p.z);
		pl.fade = 1;
	}

	for (const [id, pl] of players) {
		if (!alive.has(id)) pl.fade -= 0.02;
		if (pl.fade <= 0) {
			scene.remove(pl.mesh);
			players.delete(id);
		} else {
			pl.mesh.material.opacity = pl.fade;
			pl.mesh.material.transparent = true;
		}
	}
}

setInterval(updatePlayers, 1000);

/* =========================
   VOLUMETRIC SHADER
========================= */

const VolumetricShader = {
	uniforms: {
		tDiffuse: { value: null },
		tDepth: { value: null },
		cameraNear: { value: camera.near },
		cameraFar: { value: camera.far },
		time: { value: 0 },
		uPlayers: { value: Array.from({ length: MAX_PLAYERS }, () => new THREE.Vector3()) },
		uPlayerCount: { value: 0 }
	},
	vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position.xy, 0.0, 1.0);
		}
	`,
	fragmentShader: `
		#include <packing>
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float time;
		uniform vec3 uPlayers[32];
		uniform int uPlayerCount;
		varying vec2 vUv;

		float readDepth(vec2 uv) {
			float z = texture2D(tDepth, uv).x;
			return perspectiveDepthToViewZ(z, cameraNear, cameraFar);
		}

		vec3 raymarch(vec3 ro, vec3 rd, float maxT) {
			vec3 col = vec3(0.0);
			float t = 0.0;
			for (int i = 0; i < 64; i++) {
				if (t > maxT) break;
				vec3 p = ro + rd * t;
				float fog = exp(-length(p.xz) * 0.002);
				col += vec3(0.3, 0.5, 1.0) * fog * 0.03;
				t += 40.0;
			}
			return col;
		}

		void main() {
			float depth = -readDepth(vUv);
			vec3 ro = vec3(0.0, 800.0, 0.0);
			vec3 rd = normalize(vec3(vUv - 0.5, -1.0));
			vec3 fog = raymarch(ro, rd, depth);

			vec3 base = texture2D(tDiffuse, vUv).rgb;
			gl_FragColor = vec4(base + fog, 1.0);
		}
	`
};

/* =========================
   COMPOSER
========================= */

const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const volPass = new ShaderPass(VolumetricShader);
volPass.renderToScreen = true;
composer.addPass(volPass);

/* =========================
   ANIMATE
========================= */

function animate(t) {
	requestAnimationFrame(animate);
	volPass.uniforms.time.value = t * 0.001;

	let i = 0;
	for (const p of players.values()) {
		if (i >= MAX_PLAYERS) break;
		volPass.uniforms.uPlayers.value[i].copy(p.mesh.position);
		i++;
	}
	volPass.uniforms.uPlayerCount.value = i;

	composer.render();
}

animate();
