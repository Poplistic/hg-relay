<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { Sky } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/objects/Sky.js";

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 10000);
camera.position.set(2000, 1600, 2000);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   SKY
====================== */

const sky = new Sky();
sky.scale.setScalar(10000);
scene.add(sky);

const sun = new THREE.Vector3();
sky.material.uniforms.turbidity.value = 10;
sky.material.uniforms.rayleigh.value = 2;
sky.material.uniforms.mieCoefficient.value = 0.005;
sky.material.uniforms.mieDirectionalG.value = 0.8;

/* ======================
   LIGHTS
====================== */

const dirLight = new THREE.DirectionalLight(0xffffff, 3);
scene.add(dirLight);
scene.add(new THREE.AmbientLight(0x404060, 0.4));

/* ======================
   PLAYERS
====================== */

const playerGroup = new THREE.Group();
scene.add(playerGroup);

const DOT_RADIUS = 6;          // visual size
const HITBOX_RADIUS = 40;      // clickable size (mobile friendly)

function makePlayerMarker() {
	const group = new THREE.Group();

	// Visible dot
	const dot = new THREE.Mesh(
		new THREE.SphereGeometry(DOT_RADIUS, 16, 16),
		new THREE.MeshBasicMaterial({ color: 0x00ff00 })
	);
	group.add(dot);

	// Invisible hitbox
	const hitbox = new THREE.Mesh(
		new THREE.SphereGeometry(HITBOX_RADIUS, 16, 16),
		new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })
	);
	hitbox.userData.isHitbox = true;
	group.add(hitbox);

	group.userData = {
		dot,
		hitbox,
		lastHealth: -1
	};

	return group;
}

const playerMarkers = new Map();

/* ======================
   PLAYER UPDATES
====================== */

function updatePlayers(data) {
	const seen = new Set();

	for (const p of data) {
		seen.add(p.id);

		if (!playerMarkers.has(p.id)) {
			const m = makePlayerMarker();
			playerGroup.add(m);
			playerMarkers.set(p.id, m);
		}

		const m = playerMarkers.get(p.id);
		m.position.set(p.x, 20, p.z);
		m.userData.playerId = p.id;
	}

	for (const [id, marker] of playerMarkers) {
		if (!seen.has(id)) {
			playerGroup.remove(marker);
			playerMarkers.delete(id);
		}
	}
}

/* ======================
   FETCH LOOP
====================== */

let lighting = null;

setInterval(async () => {
	updatePlayers(await fetch("/map").then(r => r.json()));
	lighting = await fetch("/lighting").then(r => r.json());
}, 200);

/* ======================
   CLICK / TOUCH TRACKING
====================== */

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
let trackedMarker = null;

function handlePointer(event) {
	const rect = renderer.domElement.getBoundingClientRect();

	const clientX = event.touches ? event.touches[0].clientX : event.clientX;
	const clientY = event.touches ? event.touches[0].clientY : event.clientY;

	pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
	pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;

	raycaster.setFromCamera(pointer, camera);

	const hitboxes = [];
	playerMarkers.forEach(m => hitboxes.push(m.userData.hitbox));

	const hits = raycaster.intersectObjects(hitboxes, false);

	if (hits.length > 0) {
		trackedMarker = hits[0].object.parent;
	} else {
		trackedMarker = null;
	}
}

renderer.domElement.addEventListener("click", handlePointer);
renderer.domElement.addEventListener("touchstart", handlePointer, { passive: true });

/* ======================
   ANIMATE
====================== */

function animate() {
	requestAnimationFrame(animate);

	if (lighting) {
		sun.set(...lighting.sunDirection);
		sky.material.uniforms.sunPosition.value.copy(sun.multiplyScalar(5000));
		dirLight.position.copy(sun);
		dirLight.intensity = lighting.brightness * 1.2;
	}

	// Smooth camera tracking
	if (trackedMarker) {
		const target = trackedMarker.position.clone();
		controls.target.lerp(target, 0.1);
	}

	controls.update();
	renderer.render(scene, camera);
}

animate();
</script>
