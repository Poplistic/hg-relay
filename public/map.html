<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HG Arena Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
	body {
		margin: 0;
		overflow: hidden;
		background: black;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>
<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
import { ShaderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   CONSTANTS
====================== */

const MAX_PLAYERS = 24;
const SCAN_SPEED = 64;
const SCAN_MAX = 3500;

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.autoClear = false;
document.body.appendChild(renderer.domElement);

const depthTexture = new THREE.DepthTexture();
depthTexture.type = THREE.UnsignedShortType;

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 8000);
camera.position.set(1800, 1400, 1800);

/* ======================
   CONTROLS
====================== */

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 400;
controls.maxDistance = 5000;
controls.maxPolarAngle = Math.PI / 2.1;
controls.target.set(0, 0, 0);

/* ======================
   LIGHTING
====================== */

scene.add(new THREE.AmbientLight(0x222222));

const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(800, 1600, 600);
scene.add(sun);

/* ======================
   ARENA
====================== */

new OBJLoader().load("./arena.obj", obj => {
	obj.traverse(m => {
		if (!m.isMesh) return;
		m.material = new THREE.MeshStandardMaterial({
			color: 0x111111,
			roughness: 1,
			metalness: 0
		});
	});
	scene.add(obj);
});

/* ======================
   NAME SPRITE
====================== */

function makeNameSprite(name) {
	const canvas = document.createElement("canvas");
	const ctx = canvas.getContext("2d");

	ctx.font = "bold 32px Arial";
	const textWidth = ctx.measureText(name).width;

	canvas.width = textWidth + 20;
	canvas.height = 48;

	ctx.font = "bold 32px Arial";
	ctx.fillStyle = "rgba(0,0,0,0.6)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	ctx.fillStyle = "#ffffff";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(name, canvas.width / 2, canvas.height / 2);

	const texture = new THREE.CanvasTexture(canvas);
	texture.minFilter = THREE.LinearFilter;

	const material = new THREE.SpriteMaterial({
		map: texture,
		transparent: true
	});

	const sprite = new THREE.Sprite(material);
	sprite.scale.set(canvas.width * 0.6, canvas.height * 0.6, 1);
	sprite.position.y = 45;

	return sprite;
}

/* ======================
   PLAYERS
====================== */

const players = new Map();

const markerGeo = new THREE.SphereGeometry(18, 16, 16);
const markerMat = new THREE.MeshBasicMaterial({
	color: 0x00ff00,
	transparent: true
});

/* ======================
   FETCH PLAYERS
====================== */

async function updatePlayers() {
	const data = await fetch("/map").then(r => r.json());
	const aliveIds = new Set(data.map(p => p.userId));

	for (const p of data) {
		let pl = players.get(p.userId);

		if (!pl) {
			const mesh = new THREE.Mesh(markerGeo, markerMat.clone());
			const label = makeNameSprite(p.name ?? "Unknown");

			mesh.add(label);
			scene.add(mesh);

			pl = {
				mesh,
				label,
				lastPos: new THREE.Vector3(),
				fade: 1,
				alive: true
			};

			players.set(p.userId, pl);
		}

		pl.mesh.position.set(p.x, 15, p.z);
		pl.lastPos.copy(pl.mesh.position);
		pl.fade = 1;
		pl.alive = true;
	}

	for (const [id, pl] of players) {
		if (!aliveIds.has(id)) {
			pl.alive = false;
			pl.fade -= 0.01;

			if (pl.mesh) {
				pl.mesh.material.opacity = pl.fade;
				pl.label.material.opacity = pl.fade;

				if (pl.fade <= 0) {
					scene.remove(pl.mesh);
					pl.mesh = null;
				}
			}
		}
	}
}

setInterval(updatePlayers, 1000);

/* ======================
   VOLUMETRIC SHADER
====================== */
const VolumetricShader = {
	uniforms: {
		tDiffuse: { value: null },
		tDepth: { value: depthTexture },
		cameraNear: { value: camera.near },
		cameraFar: { value: camera.far },

		uPlayers: { value: Array.from({ length: MAX_PLAYERS }, () => new THREE.Vector3()) },
		uPlayerCount: { value: 0 },

		uGhosts: { value: Array.from({ length: MAX_PLAYERS }, () => new THREE.Vector3()) },
		uGhostCount: { value: 0 },

		uScanRadius: { value: 0 },
		uScanWidth: { value: 120.0 }
	},
	vertexShader: `...`,
	fragmentShader: `...`
};

/* ======================
   COMPOSER
====================== */

const composer = new EffectComposer(renderer);
composer.renderTarget1.depthTexture = depthTexture;
composer.renderTarget2.depthTexture = depthTexture;

composer.addPass(new RenderPass(scene, camera));

const volPass = new ShaderPass(VolumetricShader);
volPass.renderToScreen = true;
composer.addPass(volPass);

/* ======================
   ANIMATE
====================== */

function animate(t) {
	requestAnimationFrame(animate);
	controls.update();

	volPass.uniforms.uScanRadius.value =
		(t * 0.001 * SCAN_SPEED) % SCAN_MAX;

	let alive = 0, ghosts = 0;
	for (const pl of players.values()) {
		if (pl.alive && alive < MAX_PLAYERS)
			volPass.uniforms.uPlayers.value[alive++].copy(pl.lastPos);
		if (!pl.alive && ghosts < MAX_PLAYERS)
			volPass.uniforms.uGhosts.value[ghosts++].copy(pl.lastPos);
	}

	volPass.uniforms.uPlayerCount.value = alive;
	volPass.uniforms.uGhostCount.value = ghosts;

	composer.render();
}

animate();

/* ======================
   RESIZE
====================== */

addEventListener("resize", () => {
	camera.aspect = innerWidth / innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);
	composer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
