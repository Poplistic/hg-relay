<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
	body {
		margin:0;
		overflow:hidden;
		background:black;
	}
	canvas { display:block }

	.ui {
		position:absolute;
		color:white;
		font-family:system-ui, sans-serif;
		background:rgba(20,20,20,.65);
		backdrop-filter: blur(6px);
		border:1px solid rgba(255,255,255,.1);
		border-radius:8px;
		padding:8px 10px;
		font-size:12px;
		box-shadow:0 0 20px rgba(0,0,0,.6);
	}

	input {
		background:#111;
		color:white;
		border:1px solid #333;
		border-radius:4px;
		padding:4px;
	}

	#input {
		width:100%;
		box-sizing:border-box;
		display:block;
	}

	#log div {
		opacity:1;
		transition:opacity 1.2s ease;
	}
	#log.fade div {
		opacity:0;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   RENDERER
====================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE + FOG
====================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050508);
scene.fog = new THREE.FogExp2(0x050508, 0.000045);

/* ======================
   CAMERA
====================== */
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 20000);
camera.position.set(2000,2000,2000);

/* ======================
   CONTROLS
====================== */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ======================
   LIGHTING
====================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(3000,6000,2000);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.left = -6000;
sun.shadow.camera.right = 6000;
sun.shadow.camera.top = 6000;
sun.shadow.camera.bottom = -6000;
scene.add(sun);

/* ======================
   GROUPS
====================== */
const playerGroup = new THREE.Group();
const spectatorGroup = new THREE.Group();
scene.add(playerGroup, spectatorGroup);

/* ======================
   LOAD ARENA
====================== */
const loader = new OBJLoader();
let terrainMesh = null;

loader.load("arena.obj", obj=>{
	obj.traverse(m=>{
		if (m.isMesh) {
			m.castShadow = true;
			m.receiveShadow = true;
			m.material.side = THREE.DoubleSide;
		}
	});
	obj.scale.set(1,1,1);
	scene.add(obj);
	terrainMesh = obj;
});

/* ======================
   UI
====================== */
function ui(t,l,r,b){
	const d=document.createElement("div");
	d.className="ui";
	if(t)d.style.top=t;
	if(l)d.style.left=l;
	if(r)d.style.right=r;
	if(b)d.style.bottom=b;
	document.body.appendChild(d);
	return d;
}

const tributeUI = ui("10px","10px");
const killUI = ui("10px",null,"10px");
const spectatorUI = ui(null,null,"10px","160px");
const chatUI = ui(null,"10px",null,"10px");

chatUI.innerHTML = `
	<div id="log" style="height:120px;overflow:auto;margin-bottom:6px"></div>
	<input id="input" placeholder="chat">
`;

/* ======================
   NAME FILTER
====================== */
let badNames = [];
fetch("/badnames.txt")
	.then(r=>r.text())
	.then(t=>{
		badNames = t.split("\n").map(w=>w.trim().toLowerCase()).filter(Boolean);
	});

function isNameClean(n){
	const s=n.toLowerCase();
	return !badNames.some(b=>s.includes(b));
}

/* ======================
   SOCKET
====================== */
const socket = io();

/* ======================
   SPECTATOR NAME
====================== */
let spectatorName=null;
(function promptName(){
	while(!spectatorName){
		const n=prompt("Choose a spectator name:");
		if(!n||n.length<3||n.length>16)continue;
		if(!isNameClean(n)){ alert("Name not allowed"); continue; }
		spectatorName=n;
		socket.emit("spectator:name", n);
	}
})();

/* ======================
   CHAT
====================== */
let lastChatTime=0;
const CHAT_COOLDOWN=1200;
let chatFadeTimer=null;

function resetChatFade(){
	const log=document.getElementById("log");
	log.classList.remove("fade");
	clearTimeout(chatFadeTimer);
	chatFadeTimer=setTimeout(()=>log.classList.add("fade"),8000);
}

document.getElementById("input").addEventListener("keydown",e=>{
	if(e.key!=="Enter"||!e.target.value)return;
	const now=performance.now();
	if(now-lastChatTime<CHAT_COOLDOWN)return;
	lastChatTime=now;
	socket.emit("chat:send",e.target.value);
	e.target.value="";
	resetChatFade();
});

socket.on("chat:msg",m=>{
	const log=document.getElementById("log");
	log.innerHTML+=`<div><b>${m.from}:</b> ${m.msg}</div>`;
	log.scrollTop=log.scrollHeight;
	resetChatFade();
});

/* ======================
   NAME TAG
====================== */
function makeNameTag(text,color="#fff"){
	const c=document.createElement("canvas");
	c.width=256;c.height=64;
	const x=c.getContext("2d");
	x.fillStyle="rgba(0,0,0,.55)";
	x.fillRect(0,0,256,64);
	x.fillStyle=color;
	x.font="28px system-ui";
	x.textAlign="center";
	x.textBaseline="middle";
	x.fillText(text,128,32);
	const t=new THREE.CanvasTexture(c);
	const s=new THREE.Sprite(new THREE.SpriteMaterial({map:t,transparent:true}));
	s.scale.set(160,40,1);
	s.position.y=80;
	return s;
}

/* ======================
   PLAYER
====================== */
const players=new Map();
function makePlayer(name){
	const m=new THREE.Mesh(
		new THREE.SphereGeometry(10,16,16),
		new THREE.MeshStandardMaterial({color:0x00ff88,emissive:0x003322})
	);
	const tag=makeNameTag(name);
	m.add(tag);
	m.userData.tag=tag;
	return m;
}

/* ======================
   UPDATE PLAYERS
====================== */
const ray=new THREE.Raycaster();
const down=new THREE.Vector3(0,-1,0);
const tmp=new THREE.Vector3();

async function updatePlayers(){
	const data=await fetch("/map").then(r=>r.json());
	tributeUI.innerHTML="<b>Tributes</b><br>"+data.map(p=>p.name).join("<br>");
	const active=new Set();

	for(const p of data){
		active.add(p.id);
		if(!players.has(p.id)){
			const m=makePlayer(p.name);
			playerGroup.add(m);
			players.set(p.id,m);
		}
		const m=players.get(p.id);
		tmp.set(p.x,5000,p.z);
		ray.set(tmp,down);
		const hit=terrainMesh?ray.intersectObject(terrainMesh,true)[0]:null;
		m.position.set(p.x,hit?hit.point.y+6:6,p.z);
	}
	for(const [id,m] of players)
		if(!active.has(id)){playerGroup.remove(m);players.delete(id);}
}
setInterval(updatePlayers,200);

/* ======================
   SPECTATORS
====================== */
socket.on("spectators:init",list=>{
	spectatorGroup.clear();
	spectatorUI.innerHTML="<b>Spectators</b><br>";
	list.forEach(s=>{
		const m=new THREE.Mesh(
			new THREE.SphereGeometry(12),
			new THREE.MeshStandardMaterial({color:s.color})
		);
		const tag=makeNameTag(s.name,"#aaccff");
		m.add(tag);
		spectatorGroup.add(m);
		spectatorUI.innerHTML+=`<div>‚óè ${s.name}</div>`;
	});
});

/* ======================
   FOG HEIGHT
====================== */
function updateFog(){
	scene.fog.density=0.000045*
		THREE.MathUtils.clamp(camera.position.y/4000,0.2,1.4);
}

/* ======================
   LOOP
====================== */
function animate(){
	requestAnimationFrame(animate);
	updateFog();
	controls.update();
	for(const g of [playerGroup,spectatorGroup])
		for(const m of g.children)
			m.children.forEach(c=>c.isSprite&&c.quaternion.copy(camera.quaternion));
	renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
