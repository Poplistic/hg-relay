<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Spectator Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
	margin:0;
	overflow:hidden;
	background:#02040a;
}
canvas { display:block }

.ui {
	position:absolute;
	color:#aefcff;
	font-family:system-ui,sans-serif;
	background:linear-gradient(180deg,rgba(0,255,255,.18),rgba(0,60,60,.05));
	backdrop-filter:blur(12px) saturate(150%);
	border:1px solid rgba(0,255,255,.4);
	border-radius:12px;
	padding:10px;
	font-size:12px;
	box-shadow:0 0 25px rgba(0,255,255,.35), inset 0 0 30px rgba(0,255,255,.1);
}

.ui::before {
	content:"";
	position:absolute;
	inset:0;
	border-radius:12px;
	background:repeating-linear-gradient(
		180deg,
		rgba(255,255,255,.04),
		rgba(255,255,255,.04) 1px,
		transparent 1px,
		transparent 3px
	);
	pointer-events:none;
}

.name {
	cursor:pointer;
	padding:4px 6px;
	border-radius:6px;
}
.name:hover {
	background:rgba(0,255,255,.18);
	box-shadow:0 0 12px rgba(0,255,255,.6);
}

input {
	width:100%;
	margin-top:6px;
	background:rgba(0,0,0,.6);
	border:1px solid rgba(0,255,255,.4);
	color:#aefcff;
	padding:6px;
	border-radius:6px;
	outline:none;
}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<a href="/fallen.html" target="_blank"
style="
	position:absolute;
	top:12px;
	right:12px;
	color:#aefcff;
	background:linear-gradient(180deg,rgba(0,255,255,.25),rgba(0,80,80,.1));
	border:1px solid rgba(0,255,255,.5);
	padding:10px 16px;
	border-radius:10px;
	text-decoration:none;
	box-shadow:0 0 20px rgba(0,255,255,.4);
">
Fallen Tributes
</a>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script type="module">
import * as THREE from "three";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";
import {
	acceleratedRaycast,
	computeBoundsTree,
	disposeBoundsTree
} from "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.7.4/build/index.module.js";

/* ======================
   BVH PATCH
====================== */
THREE.Mesh.prototype.raycast = acceleratedRaycast;
THREE.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
THREE.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;

/* ======================
   RENDERER / SCENE
====================== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x02040a);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 30000);
camera.position.set(0,1200,1800);

/* ======================
   LIGHTING
====================== */
scene.add(new THREE.AmbientLight(0xffffff,0.25));
const sun = new THREE.DirectionalLight(0xffffff,1.1);
sun.position.set(3000,6000,2000);
scene.add(sun);

/* ======================
   UI
====================== */
const tributeUI = ui("10px","10px");
const chatUI = ui(null,"10px",null,"10px");

chatUI.innerHTML = `
<div id="log" style="height:120px;overflow:auto"></div>
<input id="input" placeholder="chat">
`;

function ui(t,l,r,b){
	const d=document.createElement("div");
	d.className="ui";
	if(t)d.style.top=t;
	if(l)d.style.left=l;
	if(r)d.style.right=r;
	if(b)d.style.bottom=b;
	document.body.appendChild(d);
	return d;
}

/* ======================
   SOCKET + CHAT
====================== */
const socket = io();
const log = document.getElementById("log");
const input = document.getElementById("input");

input.addEventListener("keydown",e=>{
	if(e.key==="Enter" && input.value){
		socket.emit("chat:send", input.value);
		input.value="";
	}
});

socket.on("chat:msg",m=>{
	log.innerHTML += `<div><b>${m.from}:</b> ${m.msg}</div>`;
	log.scrollTop = log.scrollHeight;
});

/* ======================
   SHADERTOY HOLOGRAM
====================== */
const holoVertex = `
varying vec3 vPos;
void main(){
	vPos = position;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
`;

const holoFragment = `
uniform float iTime;
uniform vec2 iResolution;
varying vec3 vPos;

float hash(float n){ return fract(sin(n)*43758.5453); }

void mainImage(out vec4 fragColor, in vec2 fragCoord){
	float scan = sin(vPos.y*0.15 + iTime*6.0)*0.04;
	float noise = hash(vPos.y+iTime)*0.08;
	float band = step(0.95,fract(vPos.y*0.08+iTime*0.6));
	float alpha = 0.28 + scan + noise + band*0.12;
	fragColor = vec4(0.0,1.0,1.0,alpha);
}

void main(){
	mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

/* ======================
   ARENA
====================== */
let arenaMeshes = [];
const loader = new OBJLoader();
loader.load("/arena.obj", obj => {

	obj.traverse(c=>{
		if(c.isMesh){
			c.geometry.computeVertexNormals();
			c.geometry.computeBoundsTree();

			c.material = new THREE.ShaderMaterial({
				vertexShader:holoVertex,
				fragmentShader:holoFragment,
				transparent:true,
				depthWrite:false,
				uniforms:{
					iTime:{value:0},
					iResolution:{value:new THREE.Vector2(innerWidth,innerHeight)}
				}
			});

			arenaMeshes.push(c);
		}
	});

	const box = new THREE.Box3().setFromObject(obj);
	obj.position.sub(box.getCenter(new THREE.Vector3()));
	scene.add(obj);
});

/* ======================
   PLAYERS
====================== */
const group = new THREE.Group();
scene.add(group);
const players = new Map();

function makePlayer(){
	return new THREE.Mesh(
		new THREE.SphereGeometry(10,32,32),
		new THREE.ShaderMaterial({
			vertexShader:holoVertex,
			fragmentShader:`
			uniform float iTime;
			varying vec3 vPos;
			void main(){
				float p = sin(length(vPos)*0.6 - iTime*4.0);
				float g = smoothstep(0.2,1.0,p);
				gl_FragColor = vec4(0.0,0.6+g*0.4,1.0,1.0);
			}`,
			uniforms:{ iTime:{value:0} }
		})
	);
}

/* ======================
   UPDATE PLAYERS
====================== */
let spectating=null;

async function updatePlayers(){
	const data = await fetch("/map").then(r=>r.json());
	tributeUI.innerHTML="<b>Tributes</b><br>";
	const alive=new Set();

	for(const p of data){
		alive.add(p.id);
		if(!players.has(p.id)){
			const m=makePlayer();
			group.add(m);
			players.set(p.id,m);
		}
		const m=players.get(p.id);
		m.position.set(p.x,p.y,p.z);

		const d=document.createElement("div");
		d.className="name";
		d.textContent=p.name;
		d.onclick=()=>spectating=m;
		tributeUI.appendChild(d);
	}

	for(const [id,m] of players){
		if(!alive.has(id)){
			group.remove(m);
			players.delete(id);
		}
	}
}
setInterval(updatePlayers,200);

/* ======================
   LOOP
====================== */
function animate(){
	requestAnimationFrame(animate);

	scene.traverse(o=>{
		if(o.material?.uniforms?.iTime){
			o.material.uniforms.iTime.value+=0.016;
		}
	});

	renderer.render(scene,camera);
}
animate();

/* ======================
   RESIZE
====================== */
addEventListener("resize",()=>{
	camera.aspect=innerWidth/innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth,innerHeight);
	scene.traverse(o=>{
		if(o.material?.uniforms?.iResolution){
			o.material.uniforms.iResolution.value.set(innerWidth,innerHeight);
		}
	});
});
</script>
</body>
</html>
