<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HG Arena Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
	body {
		margin: 0;
		overflow: hidden;
		background: black;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>
<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
import { ShaderPass } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   CONSTANTS
====================== */

const MAX_PLAYERS = 24;
const SCAN_SPEED = 64;
const SCAN_MAX = 3500;

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.autoClear = false;
document.body.appendChild(renderer.domElement);

const depthTexture = new THREE.DepthTexture();
depthTexture.type = THREE.UnsignedShortType;

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 8000);
camera.position.set(1800, 1400, 1800);

/* ======================
   CONTROLS
====================== */

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 400;
controls.maxDistance = 5000;
controls.maxPolarAngle = Math.PI / 2.1;
controls.target.set(0, 0, 0);

/* ======================
   LIGHTING
====================== */

scene.add(new THREE.AmbientLight(0x222222));

const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(800, 1600, 600);
scene.add(sun);

/* ======================
   ARENA
====================== */

new OBJLoader().load("./arena.obj", obj => {
	obj.traverse(m => {
		if (!m.isMesh) return;
		m.material = new THREE.MeshStandardMaterial({
			color: 0x111111,
			roughness: 1,
			metalness: 0
		});
	});
	scene.add(obj);
});

/* ======================
   NAME LABEL
====================== */

function makeNameSprite(name) {
	const canvas = document.createElement("canvas");
	const ctx = canvas.getContext("2d");

	ctx.font = "bold 32px Arial";
	const w = ctx.measureText(name).width + 20;

	canvas.width = w;
	canvas.height = 48;

	ctx.font = "bold 32px Arial";
	ctx.fillStyle = "rgba(0,0,0,0.6)";
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	ctx.fillStyle = "#ffffff";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(name, canvas.width / 2, canvas.height / 2);

	const texture = new THREE.CanvasTexture(canvas);
	const material = new THREE.SpriteMaterial({ map: texture, transparent: true });

	const sprite = new THREE.Sprite(material);
	sprite.scale.set(canvas.width * 0.6, canvas.height * 0.6, 1);
	sprite.position.y = 45;

	return sprite;
}

/* ======================
   PLAYERS
====================== */

const players = new Map();

const markerGeo = new THREE.SphereGeometry(18, 16, 16);
const markerMat = new THREE.MeshBasicMaterial({
	color: 0x00ff00, // LIME
	transparent: true
});

/* ======================
   FETCH PLAYERS
====================== */

async function updatePlayers() {
	const data = await fetch("/map").then(r => r.json());
	const aliveIds = new Set(data.map(p => p.userId));

	for (const p of data) {
		let pl = players.get(p.userId);

		if (!pl) {
			const mesh = new THREE.Mesh(markerGeo, markerMat.clone());
			const label = makeNameSprite(p.name ?? "Unknown");
			mesh.add(label);
			scene.add(mesh);

			pl = {
				mesh,
				label,
				lastPos: new THREE.Vector3(),
				fade: 1,
				alive: true
			};
			players.set(p.userId, pl);
		}

		pl.mesh.position.set(p.x, 15, p.z);
		pl.lastPos.copy(pl.mesh.position);
		pl.fade = 1;
		pl.alive = true;
	}

	for (const [id, pl] of players) {
		if (!aliveIds.has(id)) {
			pl.alive = false;
			pl.fade -= 0.01;

			if (pl.mesh) {
				pl.mesh.material.opacity = pl.fade;
				pl.label.material.opacity = pl.fade;

				if (pl.fade <= 0) {
					scene.remove(pl.mesh);
					pl.mesh = null;
				}
			}
		}
	}
}

setInterval(updatePlayers, 1000);

/* ======================
   VOLUMETRIC SHADER
====================== */

const VolumetricShader = {
	uniforms: {
		tDiffuse: { value: null },
		tDepth: { value: depthTexture },
		cameraNear: { value: camera.near },
		cameraFar: { value: camera.far },

		uPlayers: { value: Array.from({ length: MAX_PLAYERS }, () => new THREE.Vector3()) },
		uPlayerCount: { value: 0 },

		uGhosts: { value: Array.from({ length: MAX_PLAYERS }, () => new THREE.Vector3()) },
		uGhostCount: { value: 0 },

		uScanRadius: { value: 0 },
		uScanWidth: { value: 120.0 }
	},

	vertexShader: `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position.xy, 0.0, 1.0);
		}
	`,

	fragmentShader: `
		#include <packing>
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float cameraNear;
		uniform float cameraFar;

		uniform vec3 uPlayers[24];
		uniform int uPlayerCount;
		uniform vec3 uGhosts[24];
		uniform int uGhostCount;
		uniform float uScanRadius;
		uniform float uScanWidth;

		varying vec2 vUv;

		float readDepth(vec2 uv) {
			float z = texture2D(tDepth, uv).x;
			return perspectiveDepthToViewZ(z, cameraNear, cameraFar);
		}

		float glow(vec3 p, vec3 src) {
			return exp(-length(p - src) * 0.03);
		}

		vec3 raymarch(vec3 ro, vec3 rd, float maxT) {
			vec3 col = vec3(0.0);
			float t = 0.0;

			for (int i = 0; i < 80; i++) {
				if (t > maxT) break;
				vec3 p = ro + rd * t;

				float fog = exp(-length(p.xz) * 0.002);

				float alive = 0.0;
				for (int j = 0; j < 24; j++) {
					if (j >= uPlayerCount) break;
					alive += glow(p, uPlayers[j]);
				}

				float ghost = 0.0;
				for (int j = 0; j < 24; j++) {
					if (j >= uGhostCount) break;
					float ring = abs(length(p.xz) - uScanRadius);
					ghost += glow(p, uGhosts[j]) * exp(-ring / uScanWidth);
				}

				col += (
					vec3(0.2, 0.4, 0.8) * fog +
					vec3(0.6, 0.9, 1.0) * alive +
					vec3(0.8, 0.9, 1.0) * ghost
				) * 0.025;

				t += 35.0;
			}
			return col;
		}

		void main() {
			float depth = -readDepth(vUv);
			vec3 ro = vec3(0.0, 900.0, 0.0);
			vec3 rd = normalize(vec3(vUv - 0.5, -1.0));
			vec3 fog = raymarch(ro, rd, depth);
			vec3 base = texture2D(tDiffuse, vUv).rgb;
			gl_FragColor = vec4(base + fog, 1.0);
		}
	`
};

/* ======================
   COMPOSER
====================== */

const composer = new EffectComposer(renderer);
composer.renderTarget1.depthTexture = depthTexture;
composer.renderTarget2.depthTexture = depthTexture;

composer.addPass(new RenderPass(scene, camera));

const volPass = new ShaderPass(VolumetricShader);
volPass.renderToScreen = true;
composer.addPass(volPass);

/* ======================
   ANIMATE
====================== */

function animate(t) {
	requestAnimationFrame(animate);
	controls.update();

	volPass.uniforms.uScanRadius.value =
		(t * 0.001 * SCAN_SPEED) % SCAN_MAX;

	let alive = 0, ghosts = 0;
	for (const pl of players.values()) {
		if (pl.alive && alive < MAX_PLAYERS)
			volPass.uniforms.uPlayers.value[alive++].copy(pl.lastPos);
		if (!pl.alive && ghosts < MAX_PLAYERS)
			volPass.uniforms.uGhosts.value[ghosts++].copy(pl.lastPos);
	}

	volPass.uniforms.uPlayerCount.value = alive;
	volPass.uniforms.uGhostCount.value = ghosts;

	composer.render();
}

animate();

/* ======================
   RESIZE
====================== */

addEventListener("resize", () => {
	camera.aspect = innerWidth / innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);
	composer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
