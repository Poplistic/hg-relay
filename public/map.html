<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hunger Games Digital Arena</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
	body {
		margin: 0;
		overflow: hidden;
		background: radial-gradient(#050505, #000);
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js";

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene(); // ‚ùå no fog

const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 1, 8000);
camera.position.set(0, 900, 1400);

/* ======================
   CONTROLS
====================== */

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance = 400;
controls.maxDistance = 3000;
controls.maxPolarAngle = Math.PI / 2.1;

/* ======================
   DIGITAL ARENA SHADER
====================== */

const ArenaMaterial = new THREE.ShaderMaterial({
	uniforms: {
		uTime: { value: 0 }
	},
	vertexShader: `
		varying vec3 vPos;
		void main() {
			vPos = position;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}
	`,
	fragmentShader: `
		uniform float uTime;
		varying vec3 vPos;

		#define PI 3.141592
		#define TAU (PI*2.0)

		float rand(vec2 n) {
			return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
		}

		float noise(vec2 p){
			vec2 ip = floor(p);
			vec2 u = fract(p);
			u = u*u*(3.0-2.0*u);
			return mix(
				mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
				mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),
				u.y
			);
		}

		float fbm(vec2 p) {
			float r = 0.0;
			float a = 1.0;
			for(int i = 0; i < 3; i++) {
				r += a * noise(p);
				p *= 2.0;
				a *= 0.5;
			}
			return r;
		}

		void main() {
			vec2 uv = vPos.xz * 0.002;

			float grid = abs(fract(uv.x * 20.0) - 0.5)
					   + abs(fract(uv.y * 20.0) - 0.5);

			float scan = sin((uv.y + uTime * 0.3) * 40.0) * 0.08;
			float flicker = fbm(uv * 4.0 + uTime) * 0.15;

			vec3 base = vec3(0.1, 0.35, 0.6);
			vec3 col = base + grid * 0.25 + scan + flicker;

			// height glow
			col += smoothstep(0.0, 400.0, vPos.y) * vec3(0.2, 0.4, 0.6);

			gl_FragColor = vec4(col, 1.0);
		}
	`,
	side: THREE.DoubleSide
});

/* ======================
   LOAD ARENA OBJ
====================== */

const loader = new OBJLoader();
loader.load("./arena.obj", obj => {
	obj.traverse(m => {
		if (!m.isMesh) return;

		m.material = ArenaMaterial;
		m.frustumCulled = true;
	});
	scene.add(obj);
});

/* ======================
   ANIMATE
====================== */

function animate() {
	ArenaMaterial.uniforms.uTime.value = performance.now() * 0.001;
	controls.update();
	renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);

/* ======================
   RESIZE
====================== */

window.addEventListener("resize", () => {
	camera.aspect = innerWidth / innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
