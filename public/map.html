<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Digital Arena Shader</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
	html, body {
		margin: 0;
		padding: 0;
		overflow: hidden;
		background: black;
	}
	canvas {
		display: block;
	}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>
</head>

<body>

<script type="module">
import * as THREE from "three";

/* ======================
   RENDERER
====================== */

const renderer = new THREE.WebGLRenderer({
	antialias: true,
	powerPreference: "high-performance"
});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

/* ======================
   SCENE / CAMERA
====================== */

const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

/* ======================
   SHADER MATERIAL
====================== */

const material = new THREE.ShaderMaterial({
	uniforms: {
		uTime: { value: 0 },
		uResolution: { value: new THREE.Vector2(innerWidth, innerHeight) }
	},
	vertexShader: `
		void main() {
			gl_Position = vec4(position, 1.0);
		}
	`,
	fragmentShader: `
		uniform float uTime;
		uniform vec2 uResolution;

		#define PI 3.141592
		#define TAU (PI*2.0)

		float rand(vec2 n) { 
			return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
		}

		float noise(vec2 p){
			vec2 ip = floor(p);
			vec2 u = fract(p);
			u = u*u*(3.0-2.0*u);
			float res = mix(
				mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),
				mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);
			return res*res;
		}

		float fbm(vec2 p) {
			float r = 0.0;
			float amp = 1.0;
			float freq = 1.0;
			for(int i = 0; i < 3; i++) {
				r += amp * noise(freq*p);
				amp *= 0.5;
				freq *= 2.0;
			}
			return r;
		}

		mat2 rot(float th){
			vec2 a = sin(vec2(1.5707963, 0.0) + th);
			return mat2(a, -a.y, a.x);
		}

		float animHeight(vec2 p) {
			float t = mod(uTime, 7.0);
			return fbm(p * 0.3 + t * 0.5);
		}

		float sdBox(vec3 p, vec3 b) {
			vec3 d = abs(p) - b;
			return length(max(d,0.0));
		}

		float map(vec3 p) {
			float bd = length(p.xz) - 5.0;
			if (bd > 0.1) return bd;
			vec2 id = floor(p.xz / 0.2);
			float h = animHeight(id * 0.2) * 0.5;
			p.y -= h;
			return sdBox(p, vec3(0.03, h, 0.03));
		}

		vec2 trace(vec3 ro, vec3 rd) {
			float t = 0.0;
			for(int i = 0; i < 128; i++) {
				vec3 pos = ro + rd * t;
				float d = map(pos);
				if (d < 0.002 || t > 100.0) break;
				t += d;
			}
			return vec2(t);
		}

		void main() {
			vec2 fragCoord = gl_FragCoord.xy;
			vec2 p = (fragCoord * 2.0 - uResolution) / min(uResolution.x, uResolution.y);

			float t = uTime * 0.1;
			vec3 ro = vec3(cos(t)*10.0, 5.5, sin(t)*10.0);
			vec3 ta = vec3(0.0, 1.0, 0.0);

			vec3 cw = normalize(ta - ro);
			vec3 cu = normalize(cross(cw, vec3(0.0,1.0,0.0)));
			vec3 cv = cross(cu, cw);
			vec3 rd = normalize(p.x*cu + p.y*cv + 2.5*cw);

			vec2 tr = trace(ro, rd);
			float glow = pow(max(0.0, 1.0 - tr.x * 0.02), 4.0);

			vec3 col = vec3(0.2, 0.5, 0.8) * glow * 4.0;
			col = pow(col, vec3(1.0/2.2));

			gl_FragColor = vec4(col, 1.0);
		}
	`
});

/* ======================
   FULLSCREEN QUAD
====================== */

const quad = new THREE.Mesh(
	new THREE.PlaneGeometry(2, 2),
	material
);
quad.frustumCulled = false;
scene.add(quad);

/* ======================
   ANIMATE
====================== */

function animate() {
	material.uniforms.uTime.value = performance.now() * 0.001;
	renderer.render(scene, camera);
	requestAnimationFrame(animate);
}
animate();

/* ======================
   RESIZE
====================== */

window.addEventListener("resize", () => {
	renderer.setSize(innerWidth, innerHeight);
	material.uniforms.uResolution.value.set(innerWidth, innerHeight);
});
</script>

</body>
</html>
