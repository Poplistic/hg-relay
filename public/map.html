<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Hunger Games Live Map</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: #0b0e14;
}

/* ===== KILL FEED ===== */
#killfeed {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 260px;
  font-family: monospace;
  color: white;
  pointer-events: none;
}

.kill {
  background: rgba(0,0,0,0.65);
  padding: 6px 10px;
  margin-bottom: 6px;
  border-left: 4px solid #ff4444;
  animation: fadeout 6s forwards;
}

@keyframes fadeout {
  0% { opacity: 1; }
  70% { opacity: 1; }
  100% { opacity: 0; }
}
</style>
</head>

<body>
<div id="killfeed"></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

/* ================= SCENE ================= */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0e14);

const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 5000);
camera.position.set(80, 80, 80);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 64, 0);
controls.update();

/* ================= LIGHT ================= */

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 0.6);
sun.position.set(200, 400, 200);
scene.add(sun);

/* ================= GRID ================= */

scene.add(new THREE.GridHelper(512, 128, 0x444444, 0x222222));

/* ================= PLAYERS ================= */

const players = new Map(); // id -> {mesh, alive, dying, deathTime}
let followTarget = null;

function createNameTag(text) {
  const canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 64;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(0, 0, 256, 64);
  ctx.fillStyle = "#ffffff";
  ctx.font = "28px monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 128, 32);

  const tex = new THREE.CanvasTexture(canvas);
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
  sprite.scale.set(8, 2, 1);
  sprite.position.y = 4;
  return sprite;
}

function createPlayer(id) {
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(1.5, 16, 16),
    new THREE.MeshStandardMaterial({ transparent: true })
  );

  mesh.material.color.setHSL(Math.random(), 0.8, 0.6);
  mesh.add(createNameTag(id));
  scene.add(mesh);

  const obj = {
    mesh,
    alive: true,
    dying: false,
    deathTime: 0
  };

  players.set(id, obj);
  return obj;
}

function startDeath(player) {
  player.dying = true;
  player.deathTime = performance.now();
  player.mesh.material.color.set(0xff0000);

  if (followTarget === player.mesh) followTarget = null;
}

async function updatePlayers() {
  const res = await fetch("/players");
  const data = await res.json();
  const seen = new Set();

  for (const p of data) {
    seen.add(p.id);

    let player = players.get(p.id);
    if (!player) player = createPlayer(p.id);

    player.mesh.position.set(p.x, p.y, p.z);

    if (player.alive && p.alive === false) {
      player.alive = false;
      startDeath(player);
    }
  }

  for (const [id, player] of players) {
    if (!seen.has(id) && !player.dying) {
      scene.remove(player.mesh);
      players.delete(id);
    }
  }
}

setInterval(updatePlayers, 500);

/* ================= CHUNKS ================= */

const chunkMeshes = new Map();

function buildChunk(blocks) {
  const geo = new THREE.BoxGeometry(1, 1, 1);
  const mat = new THREE.MeshStandardMaterial({ color: 0x888888 });
  const mesh = new THREE.InstancedMesh(geo, mat, blocks.length);

  blocks.forEach((b, i) => {
    const m = new THREE.Matrix4();
    m.setPosition(b.x, b.y, b.z);
    mesh.setMatrixAt(i, m);
  });

  return mesh;
}

async function updateChunks() {
  const cx = Math.floor(camera.position.x / 16);
  const cz = Math.floor(camera.position.z / 16);

  const res = await fetch(`/chunks?cx=${cx}&cz=${cz}&r=2`);
  const data = await res.json();

  for (const c of data) {
    const key = `${c.cx},${c.cz}`;
    if (!chunkMeshes.has(key)) {
      const mesh = buildChunk(c.blocks);
      scene.add(mesh);
      chunkMeshes.set(key, mesh);
    }
  }
}

setInterval(updateChunks, 2000);

/* ================= CLICK FOLLOW ================= */

window.addEventListener("click", (e) => {
  const mouse = new THREE.Vector2(
    (e.clientX / window.innerWidth) * 2 - 1,
    -(e.clientY / window.innerHeight) * 2 + 1
  );

  const ray = new THREE.Raycaster();
  ray.setFromCamera(mouse, camera);

  const hits = ray.intersectObjects([...players.values()].map(p => p.mesh));
  if (hits.length) followTarget = hits[0].object;
});

/* ================= KILL FEED ================= */

const killfeed = document.getElementById("killfeed");
let lastEventTime = 0;

async function updateKillFeed() {
  const res = await fetch("/events");
  const data = await res.json();

  for (const e of data) {
    if (e.time > lastEventTime) {
      lastEventTime = e.time;

      const div = document.createElement("div");
      div.className = "kill";
      div.textContent = `${e.killer} âš” ${e.victim}`;
      killfeed.prepend(div);

      setTimeout(() => div.remove(), 6000);
    }
  }
}

setInterval(updateKillFeed, 1000);

/* ================= LOOP ================= */

function animate() {
  requestAnimationFrame(animate);

  const now = performance.now();

  for (const [id, player] of players) {
    if (player.dying) {
      const t = (now - player.deathTime) / 1500;
      if (t < 1) {
        player.mesh.position.y += 0.02;
        player.mesh.material.opacity = 1 - t;
        player.mesh.rotation.y += 0.15;
      } else {
        scene.remove(player.mesh);
        players.delete(id);
      }
    }
  }

  if (followTarget) {
    const t = followTarget.position.clone();
    camera.position.lerp(t.clone().add(new THREE.Vector3(10, 12, 10)), 0.1);
    controls.target.lerp(t, 0.1);
  }

  renderer.render(scene, camera);
}

animate();

/* ================= RESIZE ================= */

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
