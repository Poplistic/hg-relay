<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Sky Editor</title>

<style>
body { margin:0; overflow:hidden; background:black; color:white; font-family:sans-serif; }

#ui {
  position:absolute;
  top:10px;
  left:10px;
  width:270px;
  padding:10px;
  background:rgba(0,0,0,0.75);
  border-radius:12px;
}

input, select, button {
  width:100%;
  margin-bottom:6px;
}
</style>
</head>

<body>

<div id="ui">
  <button onclick="undo()">Undo</button>
  <button onclick="redo()">Redo</button>
  <hr>

  <select id="list" size="4"></select>
  <button onclick="addObject()">Add Object</button>
  <hr>

  Image ID
  <input id="image">
  <img id="preview" style="width:100%;display:none">

  Text
  <input id="text">

  Yaw <input id="yaw" type="range" min="-180" max="180">
  Pitch <input id="pitch" type="range" min="-10" max="80">
  Radius <input id="radius" type="range" min="400" max="1200">
  Scale <input id="scale" type="range" min="0.5" max="3" step="0.1">

  <button onclick="save()">Save</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<script>
const API = "https://games-k04d.onrender.com/sky";
const token = localStorage.getItem("token");

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 1, 5000);
camera.position.set(0,200,600);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff,1));

scene.add(new THREE.Mesh(
  new THREE.SphereGeometry(1500,32,32),
  new THREE.MeshBasicMaterial({color:0x111133, side:THREE.BackSide})
));

let objects = [];
let selected = null;

/* ---------- UNDO / REDO ---------- */
let history = [];
let historyIndex = -1;

function snapshot() {
  const state = JSON.stringify(objects.map(o => o.data));
  if (history[historyIndex] === state) return;
  history = history.slice(0, historyIndex + 1);
  history.push(state);
  historyIndex++;
}

function restore(i) {
  objects.forEach(o => scene.remove(o.mesh));
  objects = [];

  JSON.parse(history[i]).forEach(d => {
    let mesh = new THREE.Mesh(
      new THREE.PlaneGeometry(200,100),
      new THREE.MeshBasicMaterial({transparent:true})
    );
    scene.add(mesh);
    objects.push({ data:d, mesh });
    updateMesh(objects.at(-1));
  });

  updateList();
  select(objects[0]?.data.id);
}

function undo() {
  if (historyIndex > 0) restore(--historyIndex);
}

function redo() {
  if (historyIndex < history.length - 1) restore(++historyIndex);
}

window.addEventListener("keydown", e => {
  if (e.ctrlKey && e.key === "z") undo();
  if (e.ctrlKey && e.key === "y") redo();
});

/* ---------- HELPERS ---------- */
function spherical(y,p,r){
  y = THREE.MathUtils.degToRad(y);
  p = THREE.MathUtils.degToRad(p);
  return new THREE.Vector3(
    Math.cos(p)*Math.cos(y)*r,
    Math.sin(p)*r,
    Math.cos(p)*Math.sin(y)*r
  );
}

function thumb(id){
  return `https://www.roblox.com/asset-thumbnail/image?assetId=${id.replace(/\D/g,"")}&width=420&height=420&format=png`;
}

/* ---------- OBJECTS ---------- */
function addObject(){
  let d = { id:Date.now()+"", imageId:"", text:"", yaw:0, pitch:25, radius:800, scale:1 };
  let mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(200,100),
    new THREE.MeshBasicMaterial({transparent:true})
  );
  scene.add(mesh);
  objects.push({ data:d, mesh });
  updateList();
  select(d.id);
  snapshot();
}

function updateList(){
  list.innerHTML="";
  objects.forEach(o=>{
    let opt=document.createElement("option");
    opt.value=o.data.id;
    opt.text=o.data.id;
    list.appendChild(opt);
  });
}

function select(id){
  selected = objects.find(o=>o.data.id===id);
  list.value=id;
  syncUI();
}

function updateMesh(o){
  let d=o.data;
  let pos=spherical(d.yaw,d.pitch,d.radius);
  o.mesh.position.copy(pos);
  o.mesh.lookAt(0,pos.y,0);
  o.mesh.scale.setScalar(d.scale);
}

/* ---------- UI ---------- */
function syncUI(){
  if(!selected) return;
  let d=selected.data;
  image.value=d.imageId;
  text.value=d.text;
  yaw.value=d.yaw;
  pitch.value=d.pitch;
  radius.value=d.radius;
  scale.value=d.scale;

  if(d.imageId){
    preview.src=thumb(d.imageId);
    preview.style.display="block";
    selected.mesh.material.map=new THREE.TextureLoader().load(preview.src);
    selected.mesh.material.needsUpdate=true;
  }
}

[list,image,text,yaw,pitch,radius,scale].forEach(el=>{
  el.oninput=()=>{
    if(!selected) return;
    Object.assign(selected.data,{
      imageId:image.value,
      text:text.value,
      yaw:+yaw.value,
      pitch:+pitch.value,
      radius:+radius.value,
      scale:+scale.value
    });
    updateMesh(selected);
    snapshot();
  };
});

list.onchange=()=>select(list.value);

/* ---------- DRAG ---------- */
let ray=new THREE.Raycaster(), mouse=new THREE.Vector2(), drag=false;

renderer.domElement.onmousedown=e=>{
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
  ray.setFromCamera(mouse,camera);
  let hit=ray.intersectObjects(objects.map(o=>o.mesh));
  if(hit.length){
    drag=true;
    select(objects.find(o=>o.mesh===hit[0].object).data.id);
  }
};

renderer.domElement.onmouseup=()=>{ if(drag){ drag=false; snapshot(); } };

renderer.domElement.onmousemove=e=>{
  if(!drag||!selected) return;
  selected.data.yaw+=e.movementX*0.2;
  selected.data.pitch-=e.movementY*0.2;
  syncUI();
};

/* ---------- SAVE ---------- */
async function save(){
  await fetch(API,{
    method:"POST",
    headers:{
      "Content-Type":"application/json",
      "Authorization":token
    },
    body:JSON.stringify(objects.map(o=>o.data))
  });
  alert("Saved");
}

/* ---------- LOOP ---------- */
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
